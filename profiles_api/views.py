from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework import viewsets
from rest_framework.authentication import TokenAuthentication

from rest_framework import filters  # Allow us to filter / search
from rest_framework.authtoken.views import ObtainAuthToken  # For login, ObtainAuthToken: the view to generate auth token
from rest_framework.settings import api_settings
from rest_framework.permissions import IsAuthenticatedOrReadOnly    # This make sure the viewset 
# is readonly if the user is not authenticated
from rest_framework.permissions import IsAuthenticated  # To allow only authenticated

from profiles_api import serializers, models
from profiles_api import permissions

class HelloApiView(APIView):
    """
    Test API View
    """

    # Serializer will tell what data to expect in post, put and patch request
    serializer_class = serializers.HelloSerializer

    # We are gonna to accept get request
    # format: format suffix to the end of the endpoint url
    # best practice to keep here
    def get(self, request, format=None):
        """
        Return a list of API View features
        """
        an_apiview = [
            'Uses HTTP methods as function (get, post ,patch, put, delete)',
            'Is similar to a traditional Django View',
            'Gives you the most control over your application logic',
            'Is mapped manually to URLs',
        ]

        # Must return a response, either list or dictionary
        return Response({
            'message': 'Hello',
            'an_apiview': an_apiview
        })

    def post(self, request):
        """
        Create a hello message with a name
        """
        # Retrieve serializer
        serializer = self.serializer_class(data=request.data)

        # Check if serializer is valid, and retrieve the name
        if serializer.is_valid():
            name = serializer.validated_data.get('name')
            message = f'Hello {name}'
            return Response({
                'message': message
            })
        else:
            # serializer.errors is the error that is generated by serializer
            # a dictionary of all errors base on validation rules apply to serializer.
            return Response(
                serializer.errors,
                status=status.HTTP_400_BAD_REQUEST
            )

    # Often with put you want to update a specific object.
    # pk is used to take the id of the object you want to update.
    # pk is primary key
    def put(self, request, pk=None):
        """
        Handle updating an object.
        """
        return Response({
            'method': 'PUT',
            'pk': pk
        })

    # Patch is used to update the field provide in request of the object.
    def patch(self, request, pk=None):
        """
        Handle partial update of an object.
        """
        return Response({
            'method': 'PATCH',
            'pk': pk
        })

    def delete(self, request, pk=None):
        """
        Delete an object
        """
        return Response({
            'method': 'DELETE',
            'pk': pk
        })


class HelloViewSet(viewsets.ViewSet):
    """
    Test API ViewSet
    """

    # Specify serializer_class
    serializer_class = serializers.HelloSerializer

    def list(self, request):
        """
        Return a hello message
        """
        a_viewset = [
            'Uses action (list, create, retrieve, update, partial_update)',
            'Automatically maps to URLs using Routers',
            'Provides more functionality with less code'
        ]

        return Response({
            'message': 'Hello',
            'a_viewset': a_viewset
        })

    def create(self, request):
        """
        Create a new hello message
        """
        # Retrieve serializer
        serializer = self.serializer_class(data=request.data)

        # Validate
        if serializer.is_valid():
            name = serializer.validated_data.get('name')
            message = f'Hello {name}'

            return Response({
                'message': message
            })
        else:
            return Response(
                serializer.error_messages,
                status=status.HTTP_400_BAD_REQUEST
            )

    def retrieve(self, request, pk=None):
        """
        Handle getting an object by its ID
        """
        return Response({
            'http_method': 'GET'
        })

    def update(self, request, pk=None):
        """
        Handle updating an object
        """
        return Response({
            'http_method': 'PUT'
        })
    
    def partial_update(self, request, pk=None):
        """
        Handle updating part of an object
        """
        return Response({
            'http_method': 'PATCH'
        })

    def destroy(self, request, pk=None):
        """
        Handle delete an object
        """
        return Response({
            'http_method': 'DELETE'
        })


class UserProfileViewSet(viewsets.ModelViewSet):
    """
    Handle creating and updating profiles
    """
    serializer_class = serializers.UserProfileSerializer
    queryset = models.UserProfile.objects.all()

    # Adding authentication
    authentication_classes = (TokenAuthentication, )
    # Adding permission
    permission_classes = (permissions.UpdateOwnProfile, )

    # 
    filter_backends = (filters.SearchFilter, )
    # Tell which field we want to be searchable
    search_fields = ('name', 'email', )


# The view for login and create token
class UserLoginApiView(ObtainAuthToken):
    """
    Handle creating user authentication tokens
    """
    # Other viewset have renderer_classes by default but 
    # ObtainAuthToken does not have so we need to add renderer_classes
    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES


class ProfileFeedViewSet(viewsets.ModelViewSet):
    """
    Handle creating, reading and updating profile feed items
    """
    authentication_classes = (TokenAuthentication, )
    serializer_class = serializers.ProfileFeedItemSerializer
    queryset = models.ProfileFeedItem.objects.all()

    # Make sure non-authenticated user can read only,
    # and user can only update their own status
    permission_classes = (
        permissions.UpdateOwnStatus,
        # IsAuthenticatedOrReadOnly,# Non authenticated user can read only
        IsAuthenticated,    # Only for Authenticated
    )

    # Because we want user_profile to read_only, we need to add perform_create function to our viewset.
    # The "perform_create" function get called everytime a http post is made to our viewset.
    def perform_create(self, serializer):
        """
        Set the user profile to the logged in user
        """
        # Because we add token authentication to our viewset, if a user has been authenticated, 
        # the request will have a user associated to the authenticated user.
        serializer.save(user_profile=self.request.user)

